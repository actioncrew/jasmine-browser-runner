#!/usr/bin/env node
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import { createViteJasmineRunner, loadViteJasmineBrowserConfig } from '../lib/index.js';

// Resolve __dirname in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Determine project root (where user runs the CLI)
const projectRoot = process.cwd();

// Parse CLI args
const argv = process.argv.slice(2);
const command = argv[0];

// Parse CLI flags
function parseFlags(args) {
  const flags = {
    config: null,
    headless: null, // Changed to null to distinguish between unset and false
    browser: null,
    port: null,
    help: false
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    switch (arg) {
      case '--config':
        flags.config = args[++i];
        break;
      case '--headless':
        flags.headless = true;
        break;
      case '--no-headless':
        flags.headless = false;
        break;
      case '--browser':
        flags.browser = args[++i];
        break;
      case '--port':
        flags.port = parseInt(args[++i], 10);
        break;
      case '--help':
      case '-h':
        flags.help = true;
        break;
    }
  }

  return flags;
}

// Default config template
function createDefaultConfigTemplate() {
  const projectName = getProjectName();

  // base config with placeholders
  const template = {
    "srcDir": "./projects/[projectName]/src/lib",
    "testDir": "./projects/[projectName]/src/tests",
    "outDir": "./dist/.vite-jasmine-build",
    "tsconfig": "tsconfig.json",

    "port": 8888,
    "browser": "chrome",
    "headless": false,

    "viteConfig": {
      "root": "./",
      "logLevel": "warn",
      "build": {
        "outDir": "./dist/.vite-jasmine-build",
        "sourcemap": true,
        "minify": false,
        "rollupOptions": {
          "preserveEntrySignatures": "strict",
          "output": {
            "format": "es",
            "entryFileNames": "[name].js",
            "chunkFileNames": "chunks/[name]-[hash].js",
            "preserveModules": true,
            "preserveModulesRoot": "./projects/[projectName]/src/lib"
          }
        },
        "emptyOutDir": true
      }
    },

    "viteBuildOptions": {
      "target": "es2022",
      "sourcemap": true,
      "minify": false,
      "preserveModules": true,
      "preserveModulesRoot": "./projects/[projectName]/src/lib"
    },

    "jasmineConfig": {
      "srcDir": "./dist/.vite-jasmine-build",
      "specDir": "./dist/.vite-jasmine-build",
      "srcFiles": ["**/*.js", "!**/*.spec.js", "!**/chunks/**"],
      "specFiles": ["**/*.spec.js"],
      "helpers": [],
      "env": {
        "stopSpecOnExpectationFailure": false,
        "random": false
      },
      "browser": {
        "name": "chrome",
        "headless": false
      },
      "esm": true,
      "esmFilenameExtension": ".js",
      "jsLoader": "import",
      "port": 8888,
      "reporter": "html"
    },

    "htmlOptions": {
      "title": "[projectName] Tests",
      "includeSourceScripts": true,
      "includeSpecScripts": true,
      "bootScript": "boot1"
    }
  };

  // recursive replacer for [projectName]
  function replacePlaceholders(obj) {
    if (typeof obj === 'string') {
      return obj.replace(/\[projectName\]/g, projectName);
    } else if (Array.isArray(obj)) {
      return obj.map(replacePlaceholders);
    } else if (obj && typeof obj === 'object') {
      return Object.fromEntries(
        Object.entries(obj).map(([k, v]) => [k, replacePlaceholders(v)])
      );
    }
    return obj;
  }

  return replacePlaceholders(template);
}

// Function to get project name from package.json or fallback to folder name
function getProjectName() {
  try {
    const packageJsonPath = path.join(projectRoot, 'package.json');

    if (!fs.existsSync(packageJsonPath)) {
      console.warn('‚ö†Ô∏è  No package.json found in project root, using fallback name');
      return path.basename(projectRoot);
    }

    const pkg = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    if (pkg && pkg.name) {
      // strip @scope/ if present
      return pkg.name.startsWith('@')
        ? pkg.name.split('/')[1]
        : pkg.name;
    }

    console.warn('‚ö†Ô∏è  package.json has no "name" field, using folder name');
    return path.basename(projectRoot);
  } catch (err) {
    console.error('‚ùå Failed to read project name from package.json:', err.message);
    return path.basename(projectRoot);
  }
}

// Function to create default config file
function createDefaultConfig() {
  const configPath = path.join(projectRoot, 'ts-test-runner.json');
  
  if (fs.existsSync(configPath)) {
    console.log('‚ö†Ô∏è  Configuration file already exists at:', configPath);
    return;
  }

  try {
    const defaultConfig = createDefaultConfigTemplate();
    const projectName = getProjectName();
    
    fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));
    console.log('‚úÖ Created test configuration file:', configPath);
    console.log(`üì¶ Project name: ${projectName}`);
    console.log('üìù You can customize the configuration by editing ts-test-runner.json');
    console.log('ü§ñ Set "headless": true in config or use --headless flag for CI/automation');
  } catch (err) {
    console.error('‚ùå Failed to create config file:', err.message);
    process.exit(1);
  }
}

// Function to apply CLI flag overrides to config
function applyFlagOverrides(config, flags) {
  // Override headless mode - only if explicitly set via CLI
  if (flags.headless !== null) {
    config.headless = flags.headless;
    
    // Also update nested browser config if it exists
    if (config.jasmineConfig?.browser) {
      config.jasmineConfig.browser.headless = flags.headless;
    }
  }

  // Override browser
  if (flags.browser) {
    config.browser = flags.browser;
    
    if (config.jasmineConfig?.browser) {
      config.jasmineConfig.browser.name = flags.browser;
    }
  }

  // Override port
  if (flags.port) {
    config.port = flags.port;
    
    if (config.jasmineConfig) {
      config.jasmineConfig.port = flags.port;
    }
  }

  return config;
}

// Function to run tests
async function runTests() {
  try {
    const flags = parseFlags(argv);
    
    if (flags.help) {
      showHelp();
      return;
    }

    // Parse config path from flags
    let configPath = flags.config;
    if (configPath) {
      configPath = path.resolve(projectRoot, configPath);
    }

    // Load config relative to project root
    let config = loadViteJasmineBrowserConfig(configPath);

    // Apply CLI flag overrides
    config = applyFlagOverrides(config, flags);

    // Ensure paths in config are absolute relative to project root
    if (config.srcDir) config.srcDir = path.resolve(projectRoot, config.srcDir);
    if (config.testDir) config.testDir = path.resolve(projectRoot, config.testDir);
    if (config.outDir) config.outDir = path.resolve(projectRoot, config.outDir);
    if (config.tsconfig) config.tsconfig = path.resolve(projectRoot, config.tsconfig);

    // Log running mode with more detailed information
    const mode = config.headless ? 'headless' : 'headed';
    const watchMode = config.watch ? 'watch' : 'single-run';
    const browser = config.browser || 'chrome';
    const port = config.port || 8888;
    
    console.log(`üß™ Running tests in ${mode} mode (${watchMode})`);
    console.log(`üåê Browser: ${browser}${config.headless ? ' (headless)' : ''}`);
    
    if (!config.headless) {
      console.log(`üîó Server will run on: http://localhost:${port}`);
    }
    
    if (config.headless) {
      console.log('ü§ñ Running in headless mode - perfect for CI/automation');
    }

    // Validate required directories exist
    if (!fs.existsSync(config.srcDir)) {
      console.error(`‚ùå Source directory not found: ${config.srcDir}`);
      process.exit(1);
    }
    
    if (!fs.existsSync(config.testDir)) {
      console.error(`‚ùå Test directory not found: ${config.testDir}`);
      process.exit(1);
    }

    // Start the runner
    const runner = createViteJasmineRunner(config);
    await runner.start();
  } catch (err) {
    console.error('‚ùå Test runner failed:', err);
    process.exit(1);
  }
}

// Function to show help
function showHelp() {
  console.log(`
üß™ TypeScript Test Runner

Usage:
  npx ts-test-runner [options]          Run all tests
  npx ts-test-runner init               Initialize test configuration
  npx ts-test-runner --help             Show this help message

Commands:
  init        Create a default ts-test-runner.json file in the current directory

Options:
  --config <path>     Specify a custom configuration file path
  --headless          Run tests in headless browser mode (great for CI)
  --no-headless       Force headed mode (override config)
  --browser <name>    Browser to use (chrome, firefox, edge, etc.)
  --port <number>     Port number for test server
  --help, -h          Show help information

Examples:
  npx ts-test-runner
  npx ts-test-runner init
  npx ts-test-runner --headless
  npx ts-test-runner --headless --no-watch
  npx ts-test-runner --browser firefox --port 9999
  npx ts-test-runner --config ./custom-config.json --headless

Headless Mode:
  Perfect for CI/CD pipelines and automation. Set "headless": true in your 
  config file or use the --headless flag to run tests without opening a 
  visible browser window.
  
  In headless mode:
  ‚Ä¢ Tests run directly in Node.js using Jasmine
  ‚Ä¢ No browser window opens
  ‚Ä¢ Perfect for continuous integration
  ‚Ä¢ Exits with code 0 on success, 1 on failure
  ‚Ä¢ Use --watch to keep running and re-testing on file changes

Browser Mode (Default):
  ‚Ä¢ Opens tests in a real browser window
  ‚Ä¢ Interactive HTML test runner
  ‚Ä¢ Live reload on file changes (when watch enabled)
  ‚Ä¢ Great for development and debugging
`);
}

// Main execution logic
(async () => {
  try {
    // Check for help flag first
    if (argv.includes('--help') || argv.includes('-h')) {
      showHelp();
      return;
    }

    switch (command) {
      case 'init':
        createDefaultConfig();
        break;
      
      case 'help':
        showHelp();
        break;
      
      case undefined:
        // No command provided - run tests
        await runTests();
        break;
      
      default:
        // Unknown command or command starts with flag - try to run tests
        if (command?.startsWith('--')) {
          // Command is actually a flag, run tests
          await runTests();
        } else {
          console.error(`‚ùå Unknown command: ${command}`);
          console.log('Run "npx ts-test-runner --help" for usage information');
          process.exit(1);
        }
        break;
    }
  } catch (err) {
    console.error('‚ùå CLI failed:', err);
    process.exit(1);
  }
})();